/*
 * This file is released under the MIT license.
 * Copyright (c) 2016, 2018, Mike Lischke
 *
 * See LICENSE file for more info.
 */

"use strict";

import * as fs from "fs";
import * as path from "path";

import { ATNStateType, TransitionType } from "antlr4ts/atn";

import { SourceContext } from './SourceContext';
import { GrapsDebugger } from "./GrapsDebugger";
import { ContextSymbolTable, FragmentTokenSymbol, TokenSymbol, RuleSymbol } from "./ContextSymbolTable";
import { ParserRuleContext } from "antlr4ts";
import { ScopedSymbol } from "antlr4-c3";

export enum SymbolGroupKind { // Multiple symbol kinds can be involved in a symbol lookup.
    TokenRef,
    RuleRef,
    LexerMode,
    TokenChannel,
};

export enum SymbolKind {
    Keyword,
    TokenVocab,
    Import,
    BuiltInLexerToken,
    VirtualLexerToken,
    FragmentLexerToken,
    LexerToken,
    BuiltInMode,
    LexerMode,
    BuiltInChannel,
    TokenChannel,
    ParserRule,
    Action,
    Predicate,
    Operator,
    Option
};

/**
 * A range within a text. Just like the range object in vscode the end position is not included in the range.
 * Hence when start and end position are equal the range is empty.
 */
export class LexicalRange {
    start: { column: number, row: number };
    end: { column: number, row: number };
}

// The definition of a single symbol (range and content it is made of).
export class Definition {
    text: string;
    range: LexicalRange;
};

export class SymbolInfo {
    kind: SymbolKind;
    name: string;
    source: string;
    definition: Definition | undefined;
    description: string | undefined; // Used for code completion. Provides a small description for certain symbols.
};

export enum DiagnosticType {
    Hint,
    Info,
    Warning,
    Error
};

export class DiagnosticEntry {
    type: DiagnosticType;
    message: string;
    range: LexicalRange;
};

/**
 * Contains a number of values for a lexer token. Used when constructing a token list and parse trees in the debugger.
 */
export class LexerToken {
    text: string;
    type: number;
    name: string;
    line: number;
    offset: number; // Offset in the line.
    channel: number;
    tokenIndex: number;
    startIndex: number;
    stopIndex: number;
    [key: string]: string | number | object;
};

export enum ParseTreeNodeType {
    Rule,
    Terminal,
    Error
};

/**
 * This node class is what exported parse trees are made of, which are created by the debugger interface.
 * Each node stands either for an invoked rule, a terminal node or an error node.
 */
export class ParseTreeNode {
    type: ParseTreeNodeType;

    ruleIndex?: number;  // Only valid for the rule node type.
    name: string;
    start?: LexerToken;  // ditto
    stop?: LexerToken;   // ditto

    symbol?: LexerToken; // Only valid for non-rule nodes.

    children: ParseTreeNode[]; // Available for all node types, but empty for non-rule types.
}

/**
 * All references of a rule (both lexer and parser) to other rules and string literals.
 * Lexer rules obviously cannot have any parser rule reference. String literals are mostly interesting
 * for parser rules to check for implicit lexer tokens.
 */
export class ReferenceNode {
    kind: SymbolKind;
    rules: string[];
    tokens: string[];
    literals: string[];
};

/**
 * Contains the link + node values which describe the ATN graph for a single rule.
 */
export class ATNGraphData {
    nodes: {
        id: number,         // A unique number (positive for state numbers, negative for rule nodes)
        name: string,
        type: ATNStateType,
        [key: string]: any // Index signature for values generated by JS.
    }[];
    links: {
        source: number,
        target: number,
        type: TransitionType,
        labels: string[]
    }[];
};

/**
 * Options used by the parser files generation.
 */
export interface GenerationOptions {
    baseDir?: string;    // The folder in which to run the generation process. Should be an absolute path for predictable results.
    libDir?: string;     // Search path for the ANTLR tool.
    outputDir?: string;  // The folder where to place generated files in (relative to baseDir or absolute). (default: grammar dir)
    package?: string;    // Package or namespace name for generated files. (default: none)
    language?: string;   // The target language for the generated files. (default: what's given in the grammar or Java)
    listeners?: boolean; // Generate listener files if set. (default: true)
    visitors?: boolean;  // Generate visitor files if set. (default: false)
    loadOnly?: boolean;  // Don't generate anything. Just try to load interpreter data and do interpreter setup.
    alternativeJar?: string; // Use this jar for work instead of the built-in one(s).
};

/**
 * Options used by the sentence generation.
 * Note: both min and max lexer token length are rather informative values as the actual length depends heavily on the
 *       rule structure. For instance keywords will always show up completely, even if the max token length is smaller.
 *       The all-path setting does not apply to lexer rule sets (i.e. sets of characters). Otherwise we often had to generate
 *       individual sentences for many Unicode chars. Normal alternatives are however handled depending on that setting (like in parser rules).
 *       Also keep in mind that this setting (when true) can cause a huge set of sentences to be generated. So use it with care.
 */
export interface SentenceGenerationOptions {
    startRule: string;       // The name of the rule to start from (either lexer or parser rule) (required).
    maxIterations?: number;  // The maximum number of iterations used for `+` and `*` loops in parser rules (default: 1).
    maxRecursions?: number;  // The maximum number of recursions in parser rules (default: 1);
    minTokenLength?: number; // Min count of elements in a lexer token (default: 1).
    maxTokenLength?: number; // Max count of elements in a lexer token (default: 256).
    allPaths?: boolean;      // If false a single alt in a list is randomly chosen. If true sentences for all possible alts are generated (default: false).
};

/**
 * Options for grammar text formatting. Some names, values and meanings have been taken from clang-format
 * (http://clang.llvm.org/docs/ClangFormatStyleOptions.html), but may have slight variations tailored towards ANTLR grammars.
 * Deviations from that are mentioned in comments, otherwise see clang-format and the documentation for descriptions + examples.
 */
export interface FormattingOptions {
    alignTrailingComments?: boolean; // Default: false
    allowShortBlocksOnASingleLine?: boolean; // Default: true;
    breakBeforeBraces?: boolean; // When true start predicates and actions on a new line. Default: false.
    columnLimit?: number; // Default: 100 chars.
    continuationIndentWidth?: number; // For line continuation (only used if useTab is false). Default: same as indentWith.
    indentWidth?: number; // Default: 4 chars.
    keepEmptyLinesAtTheStartOfBlocks?: boolean; // Default: false.
    maxEmptyLinesToKeep?: number; // Default: 1.
    reflowComments?: boolean; // Default: true.
    spaceBeforeAssignmentOperators?: boolean; // Default: true
    tabWidth?: number; // Default: 4.
    useTab?: boolean; // Default: true.

    // Values not found in clang-format:

    // When set to "none" places the colon directly behind the rule name. Trailing alignment aligns colons of consecutive
    // single line rules (with at least one whitespace between rule name and colon). Hanging alignment moves the
    // colon to the next line (after the normal indentation, aligning it so with the alt pipe chars).
    // Default: none.
    alignColons?: "none" | "trailing" | "hanging";

    // When `allowShortRulesOnASingleLine` is true and `alignColon` is set to "hanging" this setting determines which gets
    // precedence. If true (the default) a rule is placed on a single line if it fits, ignoring the "hanging" setting.
    singleLineOverrulesHangingColon?: boolean;
    allowShortRulesOnASingleLine?: boolean; // Like allowShortBlocksOnASingleLine, but for entire rules. Default: true.

    // Place semicolon behind last code token or on an own line (with or w/o indentation). Default: ownLine (no indentation).
    // This setting has no effect for non-rule commands that end with a semicolon (e.g. "grammar Test;", "import Blah;" etc.).
    // Such commands are always placed on a single line.
    alignSemicolons?: "none" | "ownLine" | "hanging";
    breakBeforeParens?: boolean; // For blocks: if true puts opening parentheses on an own line. Default: false.

    // Place rule internals (return value, local variables, @init, @after) all on a single line, if true. Default: false.
    ruleInternalsOnSingleLine?: boolean;
    minEmptyLines?: number; // Between top level elements, how many empty lines must exist? Default: 0.

    // When true alignments are organized in groups of lines where they apply. These line groups are separated
    // by lines where a specific alignment type does not appear. Default: true.
    groupedAlignments?: boolean;
    alignFirstTokens?: boolean; // Align first tokens in rules after the colon. Default: false.
    alignLexerCommands?: boolean; // Align arrows from lexer commands. Default: false.
    alignActions?: boolean; // Align actions ({} blocks in rules) and predicates. Default: false.
    alignLabels?: boolean; // Align alt labels (# name). Default: true.

    // When true a single alignment for labels, actions, lexer commands and trailing comments is used instead of
    // individual alignments for each type. This avoids large whitespace runs if you have a mix of these types.
    // Setting alignTrailers disables the individual alignment settings of the mentioned types.
    alignTrailers?: boolean;

    // Index signature to allow accessing properties via brackets.
    [key: string]: boolean | number | string | undefined;
};

class ContextEntry {
    context: SourceContext;
    refCount: number;
    dependencies: string[] = [];
    grammar: string; // The grammar file name.
};

export class AntlrFacade {
    // Mapping file names to SourceContext instances.
    private sourceContexts: Map<string, ContextEntry> = new Map<string, ContextEntry>();

    constructor(private importDir: string) {
    }

    /**
     * Info for unit tests.
     */
    public getSelfDiagnostics() {
        return {
            "contextCount": this.sourceContexts.keys.length
        }
    }

    private loadDependency(contextEntry: ContextEntry, depName: string): SourceContext | undefined {
        // The given import dir is used to locate the dependency (either relative to the base path or via an absolute path).
        // If we cannot find the grammar file that way we try the base folder.
        let basePath = path.dirname(contextEntry.grammar);
        let fullPath = path.isAbsolute(this.importDir) ? this.importDir : path.join(basePath, this.importDir);
        try {
            let depPath = fullPath + "/" + depName + ".g4";
            fs.accessSync(depPath, fs.constants.R_OK);
            // Target path can be read. Now check the target file.
            contextEntry.dependencies.push(depPath);
            return this.loadGrammar(depPath);
        } catch (e) {
        }

        // File not found. Try other extension.
        try {
            let depPath = fullPath + "/" + depName + ".g";
            fs.accessSync(depPath, fs.constants.R_OK);
            // Target path can be read. Now check the target file.
            contextEntry.dependencies.push(depPath);
            return this.loadGrammar(depPath);
        } catch (e) {
        }

        // Couldn't find it in the import folder. Use the base then.
        try {
            let depPath = basePath + "/" + depName + ".g4";
            fs.statSync(depPath);
            contextEntry.dependencies.push(depPath);
            return this.loadGrammar(depPath);
        } catch (e) {
        };

        try {
            let depPath = basePath + "/" + depName + ".g";
            fs.statSync(depPath);
            contextEntry.dependencies.push(depPath);
            return this.loadGrammar(depPath);
        } catch (e) {
        };

        // Ignore the dependency if we cannot find the source file for it.
        return undefined;
    }

    private parseGrammar(contextEntry: ContextEntry) {
        let oldDependencies = contextEntry.dependencies;
        contextEntry.dependencies = [];
        let newDependencies = contextEntry.context.parse();

        for (let dep of newDependencies) {
            let depContext = this.loadDependency(contextEntry, dep);
            if (depContext)
                contextEntry.context.addAsReferenceTo(depContext);
        }

        // Release all old dependencies. This will only unload grammars which have
        // not been ref-counted by the above dependency loading (or which are not used by other
        // grammars).
        for (let dep of oldDependencies)
            this.releaseGrammar(dep);
    }

    public getContext(fileName: string, source?: string | undefined): SourceContext {
        let contextEntry = this.sourceContexts.get(fileName);
        if (!contextEntry) {
            return this.loadGrammar(fileName, source);
        }
        return contextEntry.context;
    }


    /**
     * Call this to refresh the internal input stream as a preparation to a reparse call
     * or for code completion.
     * Does nothing if no grammar has been loaded for that file name.
     */
    public setText(fileName: string, source: string) {
        let contextEntry = this.sourceContexts.get(fileName);
        if (contextEntry) {
            contextEntry.context.setText(source);
        }
    }

    /**
     * Triggers a parse run for the given file name. This grammar must have been loaded before.
     */
    public reparse(fileName: string) {
        let contextEntry = this.sourceContexts.get(fileName);
        if (contextEntry) {
            this.parseGrammar(contextEntry);
        }
    }

    public loadGrammar(fileName: string, source?: string): SourceContext {
        let contextEntry = this.sourceContexts.get(fileName);
        if (!contextEntry) {
            if (!source) {
                try {
                    fs.statSync(fileName);
                    source = fs.readFileSync(fileName, 'utf8');
                } catch (e) {
                    source = "";
                };
            }

            let context = new SourceContext(fileName);
            contextEntry = { context: context, refCount: 0, dependencies: [], grammar: fileName };
            this.sourceContexts.set(fileName, contextEntry);

            // Do an initial parse run and load all dependencies of this context
            // and pass their references to this context.
            context.setText(source);
            this.parseGrammar(contextEntry);
        }
        contextEntry.refCount++;
        return contextEntry.context;
    }

    private internalReleaseGrammar(fileName: string, referencing?: ContextEntry) {
        let contextEntry = this.sourceContexts.get(fileName);
        if (contextEntry) {
            if (referencing) {
                // If a referencing context is given remove this one from the reference's dependencies list,
                // which in turn will remove the referencing context from the dependency's referencing list.
                referencing.context.removeDependency(contextEntry.context);
            }

            contextEntry.refCount--;
            if (contextEntry.refCount == 0) {
                this.sourceContexts.delete(fileName);

                // Release also all dependencies.
                for (let dep of contextEntry.dependencies)
                    this.internalReleaseGrammar(dep, contextEntry);
            }
        }
    }
    
    public releaseGrammar(fileName: string) {
        this.internalReleaseGrammar(fileName); // name is confusing here
    }

    public getDependencies(fileName: string): string[] {
        let entry = this.sourceContexts.get(fileName);
        if (!entry) {
            return [];
        }
        let dependencies: Set<SourceContext> = new Set();
        this.pushDependencyFiles(entry, dependencies);

        let result: string[] = [];
        for (let dep of dependencies) {
            result.push(dep.fileName);
        }
        return result;
    }

    private pushDependencyFiles(entry: ContextEntry, contexts: Set<SourceContext>) {
        // Using a set for the context list here, to automatically exclude duplicates.
        for (let dep of entry.dependencies) {
            let depEntry = this.sourceContexts.get(dep);
            if (depEntry) {
                this.pushDependencyFiles(depEntry, contexts);
                contexts.add(depEntry.context);
            }
        }
    }

    // methods that could request a new context
    
    public internalInfoForSymbol(context: SourceContext, column: number, row: number, limitToChildren: boolean = true): SymbolInfo | undefined {
        return context.symbolAtPosition(column, row, limitToChildren);
    };

    private internalEnclosingSymbolAtPosition(context: SourceContext, column: number, row: number,
        ruleScope: boolean = false): SymbolInfo | undefined {
        return context.enclosingSymbolAtPosition(column, row, ruleScope);
    }

    private internalListSymbols(context: SourceContext, fullList: boolean): SymbolInfo[] {
        return context.listSymbols(!fullList);
    };

    private internalGetCodeCompletionCandidates(context: SourceContext, column: number, row: number): SymbolInfo[] {
        return context.getCodeCompletionCandidates(column, row);
    };

    private internalGetDiagnostics(context: SourceContext): DiagnosticEntry[] {
        return context.getDiagnostics();
    };

    private internalRuleFromPosition(context: SourceContext, column: number, row: number): [string | undefined, number | undefined ]{
        return context.ruleFromPosition(column, row);
    }

    /**
     * Count how many times a symbol has been referenced. The given file must contain the definition of this symbol.
     */
    private internalCountReferences(context: SourceContext, symbol: string): number {
        return context.getReferenceCount(symbol);
    }

    /**
     * Determines source file and position of all occurences of the given symbol. The search includes
     * also all referencing and referenced contexts.
     */
    private internalGetSymbolOccurences(context: SourceContext, symbolName: string): SymbolInfo[] {
        let symbols = context.getSymbolOccurences(symbolName, true);

        let result: SymbolInfo[] = [];

        for (let symbol of symbols) {
            let owner = (symbol.root as ContextSymbolTable).owner;

            if (owner) {
                if (symbol.context && symbol.name == symbolName) {
                    let context = symbol.context;
                    if (symbol instanceof FragmentTokenSymbol) {
                        context = (symbol.context as ParserRuleContext).children![1];
                    } else if (symbol instanceof TokenSymbol || symbol instanceof RuleSymbol) {
                        context = (symbol.context as ParserRuleContext).children![0];
                    }

                    result.push({
                        kind: SourceContext.getKindFromSymbol(symbol),
                        name: symbolName,
                        source: owner.fileName,
                        definition: SourceContext.definitionForContext(context, true),
                        description: undefined
                    });
                }

                if (symbol instanceof ScopedSymbol) {
                    let references = symbol.getAllNestedSymbols(symbolName);
                    for (let reference of references) {
                        result.push({
                            kind: SourceContext.getKindFromSymbol(reference),
                            name: symbolName,
                            source: owner.fileName,
                            definition: SourceContext.definitionForContext(reference.context, true),
                            description: undefined
                        });
                    }
                }
            }
        }

        // Sort result by kind. This way rule definitions appear before rule references and are re-parsed first.
        return result.sort((lhs: SymbolInfo, rhs: SymbolInfo) => {
            return lhs.kind - rhs.kind;
        });
    }
    
    private internalGenerate(context: SourceContext, options: GenerationOptions): Promise<string[]> {
        let dependencies: Set<SourceContext> = new Set();
        this.pushDependencyFiles(this.sourceContexts.get(context.fileName)!, dependencies);

        return context.generate(dependencies, options);
    }

    private internalGetATNGraph(context: SourceContext, rule: string): ATNGraphData | undefined {
        return context.getATNGraph(rule);
    }

    private internalGenerateSentences(context: SourceContext, options: SentenceGenerationOptions, definitions?: Map<string, string>): string[] {
        return context.generateSentences(options, definitions);
    }

    private internalFormatGrammar(context: SourceContext, options: FormattingOptions, start: number, stop: number): [string, number, number] {
        return context.formatGrammar(options, start, stop);
    }

    private internalHasErrors(context: SourceContext): boolean {
        return context.hasErrors;
    }

    private internalCreateDebugger(context: SourceContext, dataDir: string): GrapsDebugger | undefined {
        if (!context) {
            return;
        }

        let contexts: Set<SourceContext> = new Set();
        contexts.add(context);
        this.pushDependencyFiles(this.sourceContexts.get(context.fileName)!, contexts);

        for (let dependency of contexts) {
            if (dependency.hasErrors) {
                return;
            }

            if (!dependency.isInterpreterDataLoaded) {
                dependency.setupInterpreters(dataDir);
            }
        }

        return new GrapsDebugger([...contexts]);
    }

    private internalGetReferenceGraph(context: SourceContext): Map<string, ReferenceNode> {
        return context.getReferenceGraph();
    }

    private internalGetRRDScript(context: SourceContext, rule: string): string {
        return context.getRRDScript(rule) || "";
    };

    // fast (direct) implementations of the context methods

    public infoForSymbolFast(fileName: string, fileContents: string, column: number, row: number, limitToChildren: boolean = true): SymbolInfo | undefined {
        return this.internalInfoForSymbol(this.getContext(fileName, fileContents), column, row, limitToChildren);
    };

    public enclosingSymbolAtPositionFast(fileName: string, fileContents: string, column: number, row: number,
        ruleScope: boolean = false): SymbolInfo | undefined {
        return this.internalEnclosingSymbolAtPosition(this.getContext(fileName, fileContents), column, row, ruleScope);
    }

    public listSymbolsFast(fileName: string, fileContents: string, fullList: boolean): SymbolInfo[] {
        return this.internalListSymbols(this.getContext(fileName, fileContents), fullList);
    };

    public getCodeCompletionCandidatesFast(fileName: string, fileContents: string, column: number, row: number): SymbolInfo[] {
        return this.internalGetCodeCompletionCandidates(this.getContext(fileName, fileContents), column, row);
    };

    public getDiagnosticsFast(fileName: string, fileContents: string): DiagnosticEntry[] {
        return this.internalGetDiagnostics(this.getContext(fileName, fileContents));
    };

    public ruleFromPositionFast(fileName: string, fileContents: string, column: number, row: number): [string | undefined, number | undefined ]{
        return this.internalRuleFromPosition(this.getContext(fileName, fileContents), column, row);
    }

    /**
     * Count how many times a symbol has been referenced. The given file must contain the definition of this symbol.
     */
    public countReferencesFast(fileName: string, fileContents: string, symbol: string): number {
        return this.internalCountReferences(this.getContext(fileName, fileContents), symbol);
    }

    /**
     * Determines source file and position of all occurences of the given symbol. The search includes
     * also all referencing and referenced contexts.
     */
    public getSymbolOccurencesFast(fileName: string, fileContents: string, symbolName: string): SymbolInfo[] {
        return this.internalGetSymbolOccurences(this.getContext(fileName, fileContents), symbolName);
    }
    
    public generateFast(fileName: string, fileContents: string, options: GenerationOptions): Promise<string[]> {
        return this.internalGenerate(this.getContext(fileName, fileContents), options);
    }
    
    public getATNGraphFast(fileName: string, fileContents: string, rule: string): ATNGraphData | undefined {
        return this.internalGetATNGraph(this.getContext(fileName, fileContents), rule);
    }

    public generateSentencesFast(fileName: string, fileContents: string, options: SentenceGenerationOptions, definitions?: Map<string, string>): string[] {
        return this.internalGenerateSentences(this.getContext(fileName, fileContents), options, definitions);
    }

    public formatGrammarFast(fileName: string, fileContents: string, options: FormattingOptions, start: number, stop: number): [string, number, number] {
        return this.internalFormatGrammar(this.getContext(fileName, fileContents), options, start, stop);
    }

    public hasErrorsFast(fileName: string, fileContents: string): boolean {
        return this.internalHasErrors(this.getContext(fileName, fileContents));
    }

    public createDebuggerFast(fileName: string, fileContents: string, dataDir: string): GrapsDebugger | undefined {
        return this.internalCreateDebugger(this.getContext(fileName, fileContents), dataDir);
    }

    public getReferenceGraphFast(fileName: string, fileContents: string): Map<string, ReferenceNode> {
        return this.internalGetReferenceGraph(this.getContext(fileName, fileContents));
    }

    public getRRDScriptFast(fileName: string, fileContents: string, rule: string): string {
        return this.internalGetRRDScript(this.getContext(fileName, fileContents), rule);
    }

    // slow (loading by filename) implementations of the context methods

    public infoForSymbol(fileName: string, column: number, row: number, limitToChildren: boolean = true): SymbolInfo | undefined {
        return this.internalInfoForSymbol(this.getContext(fileName), column, row, limitToChildren);
    };

    public enclosingSymbolAtPosition(fileName: string, column: number, row: number,
        ruleScope: boolean = false): SymbolInfo | undefined {
        return this.internalEnclosingSymbolAtPosition(this.getContext(fileName), column, row, ruleScope);
    }

    public listSymbols(fileName: string, fullList: boolean): SymbolInfo[] {
        return this.internalListSymbols(this.getContext(fileName), fullList);
    };

    public getCodeCompletionCandidates(fileName: string, column: number, row: number): SymbolInfo[] {
        return this.internalGetCodeCompletionCandidates(this.getContext(fileName), column, row);
    };

    public getDiagnostics(fileName: string): DiagnosticEntry[] {
        return this.internalGetDiagnostics(this.getContext(fileName));
    };

    public ruleFromPosition(fileName: string, column: number, row: number): [string | undefined, number | undefined ]{
        return this.internalRuleFromPosition(this.getContext(fileName), column, row);
    }

    /**
     * Count how many times a symbol has been referenced. The given file must contain the definition of this symbol.
     */
    public countReferences(fileName: string, symbol: string): number {
        return this.internalCountReferences(this.getContext(fileName), symbol);
    }

    /**
     * Determines source file and position of all occurences of the given symbol. The search includes
     * also all referencing and referenced contexts.
     */
    public getSymbolOccurences(fileName: string, symbolName: string): SymbolInfo[] {
        return this.internalGetSymbolOccurences(this.getContext(fileName), symbolName);
    }
    
    public generate(fileName: string, options: GenerationOptions): Promise<string[]> {
        return this.internalGenerate(this.getContext(fileName), options);
    }
    
    public getATNGraph(fileName: string, rule: string): ATNGraphData | undefined {
        return this.internalGetATNGraph(this.getContext(fileName), rule);
    }

    public generateSentences(fileName: string, options: SentenceGenerationOptions, definitions?: Map<string, string>): string[] {
        return this.internalGenerateSentences(this.getContext(fileName), options, definitions);
    }

    public formatGrammar(fileName: string, options: FormattingOptions, start: number, stop: number): [string, number, number] {
        return this.internalFormatGrammar(this.getContext(fileName), options, start, stop);
    }

    public hasErrors(fileName: string): boolean {
        return this.internalHasErrors(this.getContext(fileName));
    }

    public createDebugger(fileName: string, dataDir: string): GrapsDebugger | undefined {
        return this.internalCreateDebugger(this.getContext(fileName), dataDir);
    }

    public getReferenceGraph(fileName: string): Map<string, ReferenceNode> {
        return this.internalGetReferenceGraph(this.getContext(fileName));
    }

    public getRRDScript(fileName: string, rule: string): string {
        return this.internalGetRRDScript(this.getContext(fileName), rule);
    }
}
